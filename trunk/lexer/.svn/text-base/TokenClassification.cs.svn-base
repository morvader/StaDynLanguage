using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Parser;
using Antlr.Runtime;
using System.IO;

public class TokenClassification {

    private IDictionary<int, StaDynTokenType> tokenTypes = new Dictionary<int, StaDynTokenType> {
            {CSharpLexer.EOF, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Nl, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Lt, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Zs, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Ll, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Lu, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Lo, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Lm, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Mn, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Mc, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Nd, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Pc, StaDynTokenType.String},
            //{CSharpLexer.UNICODE_CLASS_Cf, StaDynTokenType.String},
            {CSharpLexer.TRUE, StaDynTokenType.Keyword},
            {CSharpLexer.FALSE, StaDynTokenType.Keyword},
            {CSharpLexer.DEFAULT, StaDynTokenType.Keyword}, 
            {CSharpLexer.PP_DEFINE, StaDynTokenType.Keyword},
            {CSharpLexer.PP_UNDEFINE, StaDynTokenType.Keyword}, 
            {CSharpLexer.PP_COND_IF, StaDynTokenType.Keyword},
            {CSharpLexer.PP_COND_ELIF, StaDynTokenType.Keyword},
            {CSharpLexer.PP_COND_ELSE, StaDynTokenType.Keyword},
            {CSharpLexer.PP_COND_ENDIF, StaDynTokenType.Keyword},
            {CSharpLexer.PP_LINE, StaDynTokenType.Keyword},
            {CSharpLexer.PP_ERROR, StaDynTokenType.Keyword},
            {CSharpLexer.PP_WARNING, StaDynTokenType.Keyword},
            {CSharpLexer.PP_REGION, StaDynTokenType.Keyword},
            {CSharpLexer.PP_ENDREGION, StaDynTokenType.Keyword},
            {CSharpLexer.PP_FILENAME, StaDynTokenType.Keyword},
            {CSharpLexer.PP_IDENT, StaDynTokenType.Identifier},
            {CSharpLexer.PP_STRING, StaDynTokenType.Keyword},
            {CSharpLexer.PP_NUMBER, StaDynTokenType.Keyword},
            {CSharpLexer.WHITESPACE, StaDynTokenType.WhiteSpace},
            {CSharpLexer.QUOTE, StaDynTokenType.String},
            {CSharpLexer.OPEN_PAREN, StaDynTokenType.Operator},
            {CSharpLexer.CLOSE_PAREN, StaDynTokenType.Operator},
            {CSharpLexer.LOG_NOT, StaDynTokenType.Operator},
            {CSharpLexer.LOG_AND, StaDynTokenType.Operator},
            {CSharpLexer.LOG_OR, StaDynTokenType.Operator},
            {CSharpLexer.EQUAL, StaDynTokenType.Operator},
            {CSharpLexer.NOT_EQUAL, StaDynTokenType.Operator},
            {CSharpLexer.SL_COMMENT, StaDynTokenType.Comment},
            {CSharpLexer.NEWLINE, StaDynTokenType.Delimiter},
            {CSharpLexer.NOT_NEWLINE, StaDynTokenType.Delimiter},
            {CSharpLexer.NON_NEWLINE_WHITESPACE, StaDynTokenType.Delimiter},
            {CSharpLexer.UNICODE_ESCAPE_SEQUENCE, StaDynTokenType.Text},
            {CSharpLexer.DECIMAL_DIGIT, StaDynTokenType.Literal},
            {CSharpLexer.HEX_DIGIT, StaDynTokenType.Literal},
            {CSharpLexer.LETTER_CHARACTER, StaDynTokenType.String},
            {CSharpLexer.DECIMAL_DIGIT_CHARACTER, StaDynTokenType.String},
            {CSharpLexer.CONNECTING_CHARACTER, StaDynTokenType.String},
            {CSharpLexer.COMBINING_CHARACTER, StaDynTokenType.String},
            {CSharpLexer.FORMATTING_CHARACTER, StaDynTokenType.String},
            {CSharpLexer.ABSTRACT, StaDynTokenType.Keyword},
            {CSharpLexer.AS, StaDynTokenType.Keyword},
            {CSharpLexer.BASE, StaDynTokenType.Keyword},
            {CSharpLexer.BOOL, StaDynTokenType.Keyword},
            {CSharpLexer.BREAK, StaDynTokenType.Keyword},
            {CSharpLexer.BYTE, StaDynTokenType.Keyword},
            {CSharpLexer.CASE, StaDynTokenType.Keyword},
            {CSharpLexer.CATCH, StaDynTokenType.Keyword},
            {CSharpLexer.CHAR, StaDynTokenType.Keyword},
            {CSharpLexer.CHECKED, StaDynTokenType.Keyword}, 
            {CSharpLexer.CLASS, StaDynTokenType.Keyword},
            {CSharpLexer.CONST, StaDynTokenType.Keyword},
            {CSharpLexer.CONTINUE, StaDynTokenType.Keyword},
            {CSharpLexer.DECIMAL, StaDynTokenType.Keyword}, 
            {CSharpLexer.DELEGATE, StaDynTokenType.Keyword},
            {CSharpLexer.DO, StaDynTokenType.Keyword},
            {CSharpLexer.DOUBLE, StaDynTokenType.Keyword},
            {CSharpLexer.ELSE, StaDynTokenType.Keyword},
            {CSharpLexer.ENUM, StaDynTokenType.Keyword},
            {CSharpLexer.EVENT, StaDynTokenType.Keyword},
            {CSharpLexer.EXPLICIT, StaDynTokenType.Keyword},
            {CSharpLexer.EXTERN, StaDynTokenType.Keyword},
            {CSharpLexer.FINALLY, StaDynTokenType.Keyword},
            {CSharpLexer.FIXED, StaDynTokenType.Keyword},
            {CSharpLexer.FLOAT, StaDynTokenType.Keyword},
            {CSharpLexer.FOR, StaDynTokenType.Keyword},
            {CSharpLexer.FOREACH, StaDynTokenType.Keyword},
            {CSharpLexer.GOTO, StaDynTokenType.Keyword},
            {CSharpLexer.IF, StaDynTokenType.Keyword},
            {CSharpLexer.IMPLICIT, StaDynTokenType.Keyword},
            {CSharpLexer.IN, StaDynTokenType.Keyword},
            {CSharpLexer.INT, StaDynTokenType.Keyword},
            {CSharpLexer.INTERFACE, StaDynTokenType.Keyword},
            {CSharpLexer.INTERNAL, StaDynTokenType.Keyword},
            {CSharpLexer.IS, StaDynTokenType.Keyword},
            {CSharpLexer.LOCK, StaDynTokenType.Keyword},
            {CSharpLexer.LONG, StaDynTokenType.Keyword},
            {CSharpLexer.NAMESPACE, StaDynTokenType.Keyword},
            {CSharpLexer.NEW, StaDynTokenType.Keyword},
            {CSharpLexer.NULL, StaDynTokenType.Keyword},
            {CSharpLexer.OBJECT, StaDynTokenType.Keyword},
            {CSharpLexer.OPERATOR, StaDynTokenType.Keyword},
            {CSharpLexer.OUT, StaDynTokenType.Keyword},
            {CSharpLexer.OVERRIDE, StaDynTokenType.Keyword},
            {CSharpLexer.PARAMS, StaDynTokenType.Keyword},
            {CSharpLexer.PRIVATE, StaDynTokenType.Keyword},
            {CSharpLexer.PROTECTED, StaDynTokenType.Keyword},
            {CSharpLexer.PUBLIC, StaDynTokenType.Keyword},
            {CSharpLexer.READONLY, StaDynTokenType.Keyword},
            {CSharpLexer.REF, StaDynTokenType.Keyword},
            {CSharpLexer.RETURN, StaDynTokenType.Keyword},
            {CSharpLexer.SBYTE, StaDynTokenType.Keyword},
            {CSharpLexer.SEALED, StaDynTokenType.Keyword},
            {CSharpLexer.SHORT, StaDynTokenType.Keyword},
            {CSharpLexer.SIZEOF, StaDynTokenType.Keyword},
            {CSharpLexer.STACKALLOC, StaDynTokenType.Keyword},
            {CSharpLexer.STATIC, StaDynTokenType.Keyword},
            {CSharpLexer.STRING, StaDynTokenType.Keyword},
            {CSharpLexer.STRUCT, StaDynTokenType.Keyword},
            {CSharpLexer.SWITCH, StaDynTokenType.Keyword},
            {CSharpLexer.THIS, StaDynTokenType.Keyword},
            {CSharpLexer.THROW, StaDynTokenType.Keyword},
            {CSharpLexer.TRY, StaDynTokenType.Keyword},
            {CSharpLexer.TYPEOF, StaDynTokenType.Keyword},
            {CSharpLexer.UINT, StaDynTokenType.Keyword},
            {CSharpLexer.ULONG, StaDynTokenType.Keyword},
            {CSharpLexer.UNCHECKED, StaDynTokenType.Keyword},
            {CSharpLexer.UNSAFE, StaDynTokenType.Keyword},
            {CSharpLexer.USHORT, StaDynTokenType.Keyword},
            {CSharpLexer.USING, StaDynTokenType.Keyword},
            {CSharpLexer.VIRTUAL, StaDynTokenType.Keyword},
            {CSharpLexer.VOID, StaDynTokenType.Keyword},
            {CSharpLexer.VOLATILE, StaDynTokenType.Keyword},
            {CSharpLexer.WHILE, StaDynTokenType.Keyword},
            {CSharpLexer.VAR, StaDynTokenType.Keyword},
            {CSharpLexer.DOT, StaDynTokenType.Keyword},
            {CSharpLexer.UINT_LITERAL, StaDynTokenType.Literal},
            {CSharpLexer.LONG_LITERAL, StaDynTokenType.Literal},
            {CSharpLexer.ULONG_LITERAL, StaDynTokenType.Literal},
            {CSharpLexer.DECIMAL_LITERAL, StaDynTokenType.Literal},
            {CSharpLexer.FLOAT_LITERAL, StaDynTokenType.Literal},
            {CSharpLexer.DOUBLE_LITERAL, StaDynTokenType.Literal},
            //{CSharpLexer.LITERAL_add, StaDynTokenType.String},
            //{CSharpLexer.LITERAL_remove, StaDynTokenType.String},
            //{CSharpLexer.LITERAL_get, StaDynTokenType.String},
            //{CSharpLexer.LITERAL_set, StaDynTokenType.String},
            //{CSharpLexer.LITERAL_assembly, StaDynTokenType.String},
            //{CSharpLexer.LITERAL_field, StaDynTokenType.String},
            //{CSharpLexer.LITERAL_method, StaDynTokenType.String},
            //{CSharpLexer.LITERAL_module, StaDynTokenType.String},
            //{CSharpLexer.LITERAL_param, StaDynTokenType.String},
            //{CSharpLexer.LITERAL_property, StaDynTokenType.String},
            //{CSharpLexer.LITERAL_type, StaDynTokenType.String},
            {CSharpLexer.ML_COMMENT, StaDynTokenType.LineComment},
            {CSharpLexer.IDENTIFIER, StaDynTokenType.Identifier},
            {CSharpLexer.INT_LITERAL, StaDynTokenType.Literal},
            {CSharpLexer.CHAR_LITERAL, StaDynTokenType.Literal},
            {CSharpLexer.STRING_LITERAL, StaDynTokenType.String},
            {CSharpLexer.ESCAPED_LITERAL, StaDynTokenType.String},
            {CSharpLexer.OPEN_CURLY, StaDynTokenType.Operator},
            {CSharpLexer.CLOSE_CURLY, StaDynTokenType.Operator},
            {CSharpLexer.OPEN_BRACK, StaDynTokenType.Operator},
            {CSharpLexer.CLOSE_BRACK, StaDynTokenType.Operator},
            {CSharpLexer.COMMA, StaDynTokenType.Delimiter},
            {CSharpLexer.COLON, StaDynTokenType.Operator},
            {CSharpLexer.SEMI, StaDynTokenType.Delimiter},
            {CSharpLexer.PLUS, StaDynTokenType.Operator},
            {CSharpLexer.MINUS, StaDynTokenType.Operator},
            {CSharpLexer.STAR, StaDynTokenType.Operator},
            {CSharpLexer.DIV, StaDynTokenType.Operator},
            {CSharpLexer.MOD, StaDynTokenType.Operator},
            {CSharpLexer.BIN_AND, StaDynTokenType.Operator},
            {CSharpLexer.BIN_OR, StaDynTokenType.Operator},
            {CSharpLexer.BIN_XOR, StaDynTokenType.Operator},
            {CSharpLexer.BIN_NOT, StaDynTokenType.Operator},
            {CSharpLexer.ASSIGN, StaDynTokenType.Operator},
            {CSharpLexer.LTHAN, StaDynTokenType.Operator},
            {CSharpLexer.GTHAN, StaDynTokenType.Operator},
            {CSharpLexer.QUESTION, StaDynTokenType.Operator},
            {CSharpLexer.INC, StaDynTokenType.Operator},
            {CSharpLexer.DEC, StaDynTokenType.Operator},
            {CSharpLexer.SHIFTL, StaDynTokenType.Operator},
            {CSharpLexer.SHIFTR, StaDynTokenType.Operator},
            {CSharpLexer.LTE, StaDynTokenType.Operator},
            {CSharpLexer.GTE, StaDynTokenType.Operator},
            {CSharpLexer.PLUS_ASSIGN, StaDynTokenType.Operator},
            {CSharpLexer.MINUS_ASSIGN, StaDynTokenType.Operator},
            {CSharpLexer.STAR_ASSIGN, StaDynTokenType.Operator},
            {CSharpLexer.DIV_ASSIGN, StaDynTokenType.Operator},
            {CSharpLexer.MOD_ASSIGN, StaDynTokenType.Operator},
            {CSharpLexer.BIN_AND_ASSIGN, StaDynTokenType.Operator},
            {CSharpLexer.BIN_OR_ASSIGN, StaDynTokenType.Operator},
            {CSharpLexer.BIN_XOR_ASSIGN, StaDynTokenType.Operator},
            {CSharpLexer.SHIFTL_ASSIGN, StaDynTokenType.Operator},
            {CSharpLexer.SHIFTR_ASSIGN, StaDynTokenType.Operator},
            {CSharpLexer.DEREF, StaDynTokenType.Operator},
            //{CSharpLexer.PP_DIRECTIVE, StaDynTokenType.String},
    };

    // * Singleton
    private TokenClassification() { }
    private static TokenClassification instance = new TokenClassification();
    public static TokenClassification Instance {
        get { return instance; }
    }

    public StaDynTokenType getTokenType(int tokenType) {
        if (!this.tokenTypes.Keys.Contains(tokenType))
            // * Default Token Type
            return StaDynTokenType.Text;
        return this.tokenTypes[tokenType];
    }

}
